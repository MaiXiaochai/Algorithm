# Algorithm

一些算法练习 `Python`版

##### 1.基本算法

+ [汉诺塔](base/hanoi.py)
+ [查找](base/search.py)
    + 顺序查找
    + 二分查找
+ 排序
    + 简述
        + 排序：将一组”无序“的记录序列调整为“有序”的记录的序列
        + 列表排序：无序列表变为有序列表
        + 低效排序
            + [冒泡排序](base/bubble_sort.py)
            + [选择排序](base/select_sort.py)
            + [插入排序](base/insert_sort.py)
        + 高效排序
            + [快速排序](base/quick_sort.py)
            + 堆排序
            + 归并排序
        + 其它排序
            + 希尔排序
            + 计数排序
            + 基数排序
    + 低效排序
        + [冒泡排序](base/bubble_sort.py)
            + 概念：列表每两个相邻的数，如果前面(索引序号小)的比后面的大，则交换这两个数
            + 一趟排序完成后，则无序区减少一个数，有序区增加一个数
            + 时间复杂度: O(n<sup>2</sup>)

        + [选择排序](base/select_sort.py)
            + 概念：每次将无序区中最大的值取出来，放到有序区的最右侧
            + 时间复杂度: O(n<sup>2</sup>)

        + [插入排序](base/insert_sort.py)
            + 思想：从无序区取出一个值，与有序区的值按从右向左的顺序比较，插入合适的位置，其右边的值都向右移动
            + 时间复杂度: O(n<sup>2</sup>)

    + 高效排序
        + [快速排序](base/quick_sort.py)
            + 思想：
                + 取第一个元素`p`(任意一个元素，这里选了第一个)，使元素`p`归位
                + 列表被`p`分为两部分，左边都比`p`小，右边都比`p`大
                + 递归完成排序
            + 时间复杂度：O(nlogn)
                + 每一层的时间复杂度为 O(n)，一共有 logn层，所以，时间复杂度为 O(nlogn)
            + 快速排序的问题
                + 递归消耗内存
                + 编程语言的最大递归深度限制
                    + 如`Python`
                    + 解决：可通过设置增加递归深度，`sys.setrecursionlimit(100000)`
                + 最坏情况，倒序列表的时间复杂度为 O(n<sup>2</sup>)
                    + 解决：将`p`随机取，极大降低最坏情况出现的概率

        + [堆排序](base/)
            + 一些知识点：
                + 树
                    + 一种数据结构，比如目录树
                    + 一种可以递归定义的数据结构
                    + 由`n`个节点组成的集合
                        + 若`n = 0`，这是一颗空树
                        + 若`n > 0`, 那存在`1`个节点作为树的根节点，其它节点可以分为`m`个集合, 每个集合本身又是一棵树

                    + 一些概念
                        + 根节点(图中`A`为根节点)
                        + 叶子节点：没有下级节点的节点
                        + 树的深度（高度）：最深有几层
                        + 节点的度，该节点有`n`个子节点则该节点的度就是`n`
                        + 树的度，整个树中，节点度最大的度值（在图中，`A`节点的度为6，在树内部最大，该树的度就是6）
                        + 子节点，如 `E`是`A`的子节点
                        + 父节点，如 `A`是`E`的子节点
                        + 子树
                    + ![img.png](base/tree.png)

                + 二叉树
                    + 概念：度不超过2的树（每个节点最多分两个叉）
                    + 每个节点最多有两个子节点
                        + 两个子节点被区分为左子节点和右子节点
                    + ![img.png](base/tree2.png)

                + 满二叉树：每一层的节点数都达到最大值
                    + ![img.png](base/tree3.png)

                + 完全二叉树
                    + 叶节点只能出现在最下层和次下层
                    + 并且最下面一层的节点都集中在该层最左边的若干位置的二叉树
                    + ![img.png](base/完全二叉树.png)
                    + 非完全二叉树
                        + ![img.png](base/非完全二叉树.png)

                + 二叉树的储存方式
                    + 链式存储方式（看后面数据结构部分）
                    + 顺序存储方式，用列表存
                    + 找子节点 父节点 索引为 `i`
                        + 左子节点索引：`2i + 1`
                        + 右子节点索引：`2i + 2`
                        + ![img.png](base/顺序存储_父子节点索引关系.png
##### 参考资料

+ [清华计算机博士带你学习Python算法+数据结构](https://www.bilibili.com/video/BV1mp4y1D7UP?from=search&seid=2163581747729103305)